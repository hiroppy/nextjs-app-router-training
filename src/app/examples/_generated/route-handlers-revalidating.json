{
  "meta": {
    "kind": "route-handlers",
    "path": "route-handlers-revalidating",
    "title": "Revalidating Data",
    "description": "\nrevalidatePath only invalidates the cache when the included path is next visited.\nThis means calling revalidatePath with a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited.\n    ",
    "doc": "https://nextjs.org/docs/app/api-reference/functions/revalidatePath"
  },
  "codes": {
    "[revalidate-path-page]/api/route.ts": "import { revalidatePath } from \"next/cache\";\n\nexport async function GET() {\n  revalidatePath(\n    \"/examples/route-handlers-revalidating/[revalidate-path-page]\",\n    \"page\",\n  );\n\n  return Response.json({\n    revalidated: true,\n    now: Date.now(),\n  });\n}\n",
    "[revalidate-path-page]/page.tsx": "\"use client\";\n\nimport { useFetch } from \"../_hooks/useFetch\";\n\nexport default function Page() {\n  const path = \"/examples/route-handlers-revalidating/revalidate-path/api\";\n  const { data } = useFetch<{ now: number }>(path);\n\n  return <p>revalidated: {data?.now}</p>;\n}\n",
    "_hooks/useFetch.ts": "import { useEffect, useState } from \"react\";\n\nexport function useFetch<T = unknown>(path: string, tags?: string[]) {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    (async () => {\n      try {\n        setLoading(true);\n        const data = await (\n          await fetch(path, {\n            next: { tags },\n          })\n        ).json();\n\n        setData(data);\n      } catch (e) {\n        if (e instanceof Error) {\n          setError(e);\n        }\n      } finally {\n        setLoading(false);\n      }\n    })();\n  }, [path, tags]);\n\n  return <const>{ data, loading, error };\n}\n",
    "api/route.ts": "import { NextResponse } from \"next/server\";\n\n// if you add POST function in this file, GET won't save the own cache\nexport async function GET() {\n  // if you execute below, GET will purge the cache automatically\n  // const tag = request.nextUrl.searchParams.get(\"tag\") ?? \"/\";\n\n  return NextResponse.json({\n    now: Date.now(),\n  });\n}\n\n// export async function POST() {\n//   return Response.json({\n//     now: Date.now(),\n//   });\n// }\n",
    "layout.tsx": "\"use client\";\n\nimport { type PropsWithChildren } from \"react\";\nimport { useFetch } from \"./_hooks/useFetch\";\n\nexport default function Layout({ children }: PropsWithChildren) {\n  const path = \"/examples/route-handlers-revalidating/api\";\n  const { data, loading } = useFetch<{ now: number }>(path);\n\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <div className=\"flex justify-between\">\n        <h2>layout</h2>\n        <button\n          type=\"button\"\n          className=\"text-right hover:text-blue-300\"\n          onClick={() => {\n            window.location.reload();\n          }}\n        >\n          Reload\n        </button>\n      </div>\n      <p>cached: {loading ? \"loading...\" : data?.now}</p>\n      {children}\n    </div>\n  );\n}\n",
    "page.tsx": "import Link from \"next/link\";\n\nexport default function Page() {\n  return (\n    <div className=\"flex flex-col gap-4\">\n      <Link href={getUrl(\"revalidate-path\", \"revalidate-path/api/route.ts\")}>\n        ðŸ‘‰ revalidatePath\n      </Link>\n      <Link href={getUrl(\"dog\", \"[revalidate-path-page]/api/route.ts\")}>\n        ðŸ‘‰ revalidatePath for segments(\"[]\")\n      </Link>\n      <Link\n        href={getUrl(\n          \"revalidate-tag?animal=dog\",\n          \"revalidate-tag/api/route.ts\",\n        )}\n      >\n        ðŸ‘‰ revalidateTag\n      </Link>\n    </div>\n  );\n}\n\nfunction getUrl(path: string, filename: string) {\n  return `/examples/route-handlers-revalidating/${path}?file-path=${filename}`;\n}\n",
    "revalidate-path/api/route.ts": "import { revalidatePath } from \"next/cache\";\n\nexport async function GET() {\n  revalidatePath(\"/examples/route-handlers-revalidating/revalidate-path\");\n\n  return Response.json({\n    revalidated: true,\n    now: Date.now(),\n  });\n}\n",
    "revalidate-path/page.tsx": "\"use client\";\n\nimport { useFetch } from \"../_hooks/useFetch\";\n\nexport default function Page() {\n  const path = \"/examples/route-handlers-revalidating/revalidate-path/api\";\n  const { data } = useFetch<{ now: number }>(path);\n\n  return <p>revalidated: {data?.now}</p>;\n}\n",
    "revalidate-tag/api/route.ts": "// issue: https://github.com/sanity-io/template-nextjs-personal-website/issues/112\n\nimport { revalidateTag } from \"next/cache\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\nexport async function GET(request: NextRequest) {\n  const tag = request.nextUrl.searchParams.get(\"tag\") ?? \"\";\n\n  revalidateTag(tag);\n\n  return NextResponse.json({\n    revalidated: true,\n    now: Date.now(),\n  });\n}\n",
    "revalidate-tag/page.tsx": "\"use client\";\n\nimport { useMemo } from \"react\";\nimport { useFetch } from \"../_hooks/useFetch\";\n\nexport default function Page() {\n  const path = \"/examples/route-handlers-revalidating/revalidate-tag/api\";\n  const tags = useMemo(() => [\"dog\"], []);\n  const { data: dataWithTags } = useFetch<{ now: number }>(path, tags);\n  const { data: dataWithNoTag } = useFetch<{ now: number }>(path);\n\n  return (\n    <div>\n      <p>revalidated: {dataWithTags?.now}</p>\n      <p>revalidated: {dataWithNoTag?.now}</p>\n    </div>\n  );\n}\n"
  }
}